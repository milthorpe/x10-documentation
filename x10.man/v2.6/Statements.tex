%% vj Wed Sep 18 19:27:18 EDT 2013
%% Updtaed to v 2.4
\chapter{Statements}\label{XtenStatements}\index{statement}

This chapter describes the statements in the sequential core of
\Xten{}.  Statements involving concurrency and distribution
are described in \Sref{XtenActivities}.

\section{Empty statement}

The empty statement \xcd";" does nothing.  

\begin{ex}
Sometimes, the syntax of X10 requires a statement in some position, but you do
not actually want to do any computation there.   
The following code searches the rail \xcd`a` for the value \xcd`v`, assumed
to appear somewhere in \xcd`a`, and returns the index at which it was found.  
There is no computation to do in the loop body, so we use an empty statement
there. 
%~~gen ^^^ Statements10
% package statements.emptystatement;
% class EmptyStatementExample {
%~~vis
\begin{xten}
static def search[T](a: Rail[T], v: T):Long {
  var i : Long;
  for(i = 0L; a(i) != v; i++)
     ;
  return i;
}
\end{xten}
%~~siv
%}
%~~neg

\end{ex}

\section{Local variable declaration}
\label{sect:LocalVarDecln}
\index{variable!declaration}
\index{var}
\index{val}

%##(LocVarDecln LocVarDeclnStmt VariableDeclaratorsWithType  VariableDeclarators VariableInitializer FormalDeclarators
\begin{bbgrammar}
%(FROM #(prod:LocVarDecln)#)
         LocVarDecln \: Mods\opt VarKeyword VariableDeclrs & (\ref{prod:LocVarDecln}) \\
                     \| Mods\opt VarDeclsWType \\
                     \| Mods\opt VarKeyword FormalDeclrs \\
%(FROM #(prod:LocVarDeclnStmt)#)
     LocVarDeclnStmt \: LocVarDecln \xcd";" & (\ref{prod:LocVarDeclnStmt}) \\
%(FROM #(prod:VarDeclsWType)#)
       VarDeclsWType \: VarDeclWType & (\ref{prod:VarDeclsWType}) \\
                     \| VarDeclsWType \xcd"," VarDeclWType \\
%(FROM #(prod:VariableDeclrs)#)
      VariableDeclrs \: VariableDeclr & (\ref{prod:VariableDeclrs}) \\
                     \| VariableDeclrs \xcd"," VariableDeclr \\
%(FROM #(prod:VariableInitializer)#)
 VariableInitializer \: Exp & (\ref{prod:VariableInitializer}) \\
%(FROM #(prod:FormalDeclrs)#)
        FormalDeclrs \: FormalDeclr & (\ref{prod:FormalDeclrs}) \\
                     \| FormalDeclrs \xcd"," FormalDeclr \\
\end{bbgrammar}
%##)

Short-lived variables are introduced by local variables declarations, as
described in \Sref{sect:LocalVarDecln}. Local variables may be declared only
within a block statement (\Sref{Blocks}). The scope of a local variable
declaration is the subsequent statements in the
block.   
%~~gen ^^^ Statements20
% package statements.should.have.locals;
% class LocalExample {
% def example(a:Long) {
%~~vis
\begin{xten}
  if (a > 1) {
     val b = a/2;
     var c : Long = 0;
     // b and c are defined here
  }
  // b and c are not defined here.
\end{xten}
%~~siv
%} }
%~~neg

Variables declared in such statements shadow variables of the same
name declared elsewhere.
A local variable of a given name, say \xcd`x`, cannot shadow another local
variable or parameter named \xcd`x` unless there is an intervening method,
constructor, initializer, or
closure declaration.
%%, or unless the inner \xcd`x` is declared inside an
%%\xcd`async` or \xcd`at` statement and the outer variable is declared outside
%% of that.   Strictly, \xcd`at` introduces a new scope that does not share the
%%variables of the external scope, so its variables do not actually shadow those
%%outside.  

\begin{ex}
The following code illustrates both legal and illegal uses of shadowing.
Note that a shadowed {\em field} name \xcd`x` can still be accessed 
as \xcd`this.x`. 

%%AT-COPY%% %~~gen ^^^ Statements4h6p
%%AT-COPY%% % package Statements4h6p;
%%AT-COPY%% %~~vis
%%AT-COPY%% \begin{xten}
%%AT-COPY%% class Shadow{
%%AT-COPY%%   var x : Long; 
%%AT-COPY%%   def this(x:Long) { 
%%AT-COPY%%      // Parameter can shadow field
%%AT-COPY%%      this.x = x; 
%%AT-COPY%%   }
%%AT-COPY%%   def example(y:Long) {
%%AT-COPY%%      val x = "shadows a field";
%%AT-COPY%%      // ERROR: val y = "shadows a param";
%%AT-COPY%%      val z = "local";
%%AT-COPY%%      for (a in [1,2,3]) {
%%AT-COPY%%         // ERROR: val x = "can't shadow local var";
%%AT-COPY%%      }
%%AT-COPY%%      async {
%%AT-COPY%%         val x = "can shadow through async";
%%AT-COPY%%      }        
%%AT-COPY%%      at (here;) {
%%AT-COPY%%         val x = "at gives a whole new namespace";
%%AT-COPY%%      }        
%%AT-COPY%%      val f = () => { 
%%AT-COPY%%        val x = "can shadow through closure";
%%AT-COPY%%        x
%%AT-COPY%%      };
%%AT-COPY%%   }
%%AT-COPY%% }
%%AT-COPY%% \end{xten}
%%AT-COPY%% %~~siv
%%AT-COPY%% %
%%AT-COPY%% %~~neg
%%AT-COPY%% 
%~~gen ^^^ Statements4h6p
% package Statements4h6p;
% // NOTEST-stupid-packaging-issue
%~~vis
\begin{xten}
class Shadow{
  var x : Long; 
  def this(x:Long) { 
     // Parameter can shadow field
     this.x = x; 
  }
  def example(y:Long) {
     val x = "shadows a field";
     // ERROR: val y = "shadows a param";
     val z = "local";
     for (a in [1,2,3]) {
        // ERROR: val x = "can't shadow local var";
     }
     async {
        // ERROR: val x = "can't shadow through async";
     }        
     val f = () => { 
       val x = "can shadow through closure";
       x
     };
     class Local {
        val f = at(here) { val x = "can here"; x };
        def this() { val x = "can here, too"; }
     }
  }
}
\end{xten}
%~~siv
%
%~~neg



\end{ex}

\begin{ex}
Note that recursive definitions of local variables is not allowed.  There are
few useful recursive declarations of objects and structs; \xcd`x`, in the
following example, has no meaningful definition.  Recursive declarations of
local functions is forbidden, even though (like \xcd`f` below) there are
meaningful uses of it.  
\begin{xten}
val x : Long = x + 1; // ERROR: recursive local declaration
val f : (Long)=>Long 
      = (n:Long) => (n <= 2) ? 1 : f(n-1) + f(n-2);
      // ERROR: recursive local declaration
\end{xten}

\end{ex}



\section{Block statement}
\index{block}
\label{Blocks}

%##(Block BlockStatements BlockInteriorStatement
\begin{bbgrammar}
%(FROM #(prod:Block)#)
               Block \: \xcd"{" BlockStmts\opt \xcd"}" & (\ref{prod:Block}) \\
%(FROM #(prod:BlockStmts)#)
          BlockStmts \: BlockInteriorStmt & (\ref{prod:BlockStmts}) \\
                     \| BlockStmts BlockInteriorStmt \\
%(FROM #(prod:BlockInteriorStmt)#)
   BlockInteriorStmt \: LocVarDeclnStmt & (\ref{prod:BlockInteriorStmt}) \\
                     \| ClassDecln \\
                     \| StructDecln \\
                     \| TypeDefDecln \\
                     \| Stmt \\
\end{bbgrammar}
%##)


A block statement consists of a sequence of statements delimited by
``\xcd"{"'' and ``\xcd"}"''. When a block is evaluated, the statements inside
of it are evaluated in order.  Blocks are useful for putting several
statements in a place where X10 asks for a single one, such as the consequent
of an \xcd`if`, and for limiting the scope of local variables.
%~~gen ^^^ Statements30
% package statements.FOR.block.heads;
% class Example {
% def example(b:Boolean, S1:(Long)=>void, S2:(Long)=>void ) {
%~~vis
\begin{xten}
if (b) {
  // This is a block
  val v = 1;
  S1(v); 
  S2(v);
}
\end{xten}
%~~siv
%  } } 
%~~neg



\section{Expression statement}

Any expression may be used as a statement.

%##(ExpStatement StatementExp
\begin{bbgrammar}
%(FROM #(prod:ExpStmt)#)
             ExpStmt \: StmtExp \xcd";" & (\ref{prod:ExpStmt}) \\
%(FROM #(prod:StmtExp)#)
             StmtExp \: Assignment & (\ref{prod:StmtExp}) \\
                     \| PreIncrementExp \\
                     \| PreDecrementExp \\
                     \| PostIncrementExp \\
                     \| PostDecrementExp \\
                     \| MethodInvo \\
                     \| ObCreationExp \\
\end{bbgrammar}
%##)

The expression statement evaluates an expression. The value of the expression
is not used. Side effects of the expression occur, and may produce results
used by following statements. Indeed, statement expressions which terminate
without side effects cannot have any visible effect on the results of the
computation. 


\begin{ex}
%~~gen ^^^ Statements40
% package Sta.tem.ent.s.expressions;
% import x10.util.*;
%~~vis
\begin{xten}
class StmtEx {
  def this() { 
     x10.io.Console.OUT.println("New StmtEx made");  }
  static def call() { 
     x10.io.Console.OUT.println("call!");}
  def example() {
     var a : Long = 0;
     a = 1; // assignment
     new StmtEx(); // allocation
     call(); // call
  }
}
\end{xten}
%~~siv
%
%~~neg
\end{ex}



\section{Labeled statement}
\index{label}
\index{statement label}


\begin{bbgrammar}
    LabeledStatement \: Id \xcd":" Statement 
\end{bbgrammar}


Statements may be labeled. The label may be used to describe the target of a
\xcd`break` statement appearing within a substatement (which, when executed,
ends the labeled statement), or, in the case of a loop, a \xcd`continue` as
well (which, when executed, proceeds to the next iteration of the loop). The
scope of a label is the statement labeled.

\begin{ex}
The label on the outer \xcd`for` statement allows \xcd`continue` and
\xcd`break` statements to continue or break it.  Without the label,
\xcd`continue` or \xcd`break` would only continue or break the inner \xcd`for`
loop. 
%~~gen ^^^ Statements50
% package state.meant.labe.L;
% class Example {
% def example(a:(Long,Long) => Long, do_things_to:(Long)=>Long) {
%~~vis
\begin{xten}
lbl : for (i in 1..10) {
   for (j in i..10) {  
      if (a(i,j) == 0) break lbl;
      if (a(i,j) == 1) continue lbl;
      if (a(i,j) == a(j,i)) break lbl;
   }
}
\end{xten}
%~~siv
%} } 
%~~neg
\end{ex}

In particular, a block statement may be labeled: \xcd` L:{S}`.  This allows
the use of \xcd`break L` within \xcd`S` to leave \xcd`S`, which can, if
carefully used, avoid deeply-nested \xcd`if`s. 

\begin{ex}
%~~gen ^^^ Statements51
% package statements51;
% abstract class Example {
% abstract def phase1(String):void;
% abstract def phase2(String):void;
% abstract def phase3(String):void;
% abstract def suitable_for_phase_2(String):Boolean;
% abstract def suitable_for_phase_3(String):Boolean;
% def example(filename: String) {
% KNOWNFAIL-labelled-blocks
%~~vis
\begin{xten}
multiphase: {
  if (!exists(filename)) break multiphase;
  phase1(filename);
  if (!suitable_for_phase_2(filename)) break multiphase;
  phase2(filename);
  if (!suitable_for_phase_3(filename)) break multiphase;
  phase3(filename);
}
// Now the file has been phased as much as possible
\end{xten}
%~~siv
%}
%~~neg
\end{ex}

\limitation{Blocks cannot currently be labeled.}

\section{Break statement}
\index{break}

%##(BreakStatement
\begin{bbgrammar}
%(FROM #(prod:BreakStmt)#)
           BreakStmt \: \xcd"break" Id\opt \xcd";" & (\ref{prod:BreakStmt}) \\
\end{bbgrammar}
%##)


An unlabeled break statement exits the currently enclosing loop or switch
statement. A labeled break statement exits the enclosing 
statement with the given label.
It is illegal to break out of a statement not defined in the current
method, constructor, initializer, or closure.  
\xcd`break` is only allowed in sequential code.

\begin{ex}
The following code searches for an element of a C-style two-dimensional
array and breaks out of the loop when it is found:
%~~gen ^^^ Statements60
% package statements.come.from.banks.and.cranks;
% class LabelledBreakeyBreakyHeart {
% def findy(a:Rail[Rail[Long]], v:Long): Boolean {
%~~vis
\begin{xten}
var found: Boolean = false;
outer: for (i in a.range)
    for (j in a(i).range)
        if (a(i)(j) == v) {
            found = true;
            break outer;
        }
\end{xten}
%~~siv
% return found;
%}}
%~~neg
\end{ex}

\section{Continue statement}
\index{continue}

%##(ContinueStatement
\begin{bbgrammar}
%(FROM #(prod:ContinueStmt)#)
        ContinueStmt \: \xcd"continue" Id\opt \xcd";" & (\ref{prod:ContinueStmt}) \\
\end{bbgrammar}
%##)
An unlabeled \xcd`continue` skips the rest of the current iteration of the
innermost enclosing loop, and proceeds on to the next.  A labeled
\xcd`continue` does the same to the enclosing loop with that label.
It is illegal to continue a loop not defined in the current
method, constructor, initializer, or closure.
\xcd`continue` is only allowed in sequential code.



\section{If statement}
\index{if}

%##(IfThenStatement IfThenElseStatement
\begin{bbgrammar}
%(FROM #(prod:IfThenStmt)#)
          IfThenStmt \: \xcd"if" \xcd"(" Exp \xcd")" Stmt & (\ref{prod:IfThenStmt}) \\
%(FROM #(prod:IfThenElseStmt)#)
      IfThenElseStmt \: \xcd"if" \xcd"(" Exp \xcd")" Stmt  \xcd"else" Stmt  & (\ref{prod:IfThenElseStmt}) \\
\end{bbgrammar}
%##)

An if statement comes in two forms: with and without an else
clause.

The if-then statement evaluates a condition expression, which must be of type
\xcd`Boolean`. If the condition is \xcd`true`, it evaluates the then-clause.
If the condition is \xcd"false", the if-then statement completes normally.

The if-then-else statement evaluates a \xcd`Boolean` expression and 
evaluates the then-clause if the condition is
\xcd"true"; otherwise, the \xcd`else`-clause is evaluated.

As is traditional in languages derived from Algol, the if-statement is syntactically
ambiguous.  That is, 
\begin{xten}
if (B1) if (B2) S1 else S2
\end{xten}
could be intended to mean either 
\begin{xten}
if (B1) { if (B2) S1 else S2 }
\end{xten} 
or 
\begin{xten}
if (B1) {if (B2) S1} else S2
\end{xten}
X10, as is traditional, attaches an \xcd`else` clause to the most recent
\xcd`if` that doesn't have one.
This example is interpreted as 
\xcd`if (B1) { if (B2) S1 else S2 }`. 



\section{Switch statement}
\index{switch}

%##(SwitchStatement SwitchBlock SwitchBlockGroups SwitchBlockGroup SwitchLabels SwitchLabel
\begin{bbgrammar}
%(FROM #(prod:SwitchStmt)#)
          SwitchStmt \: \xcd"switch" \xcd"(" Exp \xcd")" SwitchBlock & (\ref{prod:SwitchStmt}) \\
%(FROM #(prod:SwitchBlock)#)
         SwitchBlock \: \xcd"{" SwitchBlockGroups\opt SwitchLabels\opt \xcd"}" & (\ref{prod:SwitchBlock}) \\
%(FROM #(prod:SwitchBlockGroups)#)
   SwitchBlockGroups \: SwitchBlockGroup & (\ref{prod:SwitchBlockGroups}) \\
                     \| SwitchBlockGroups SwitchBlockGroup \\
%(FROM #(prod:SwitchBlockGroup)#)
    SwitchBlockGroup \: SwitchLabels BlockStmts & (\ref{prod:SwitchBlockGroup}) \\
%(FROM #(prod:SwitchLabels)#)
        SwitchLabels \: SwitchLabel & (\ref{prod:SwitchLabels}) \\
                     \| SwitchLabels SwitchLabel \\
%(FROM #(prod:SwitchLabel)#)
         SwitchLabel \: \xcd"case" ConstantExp \xcd":" & (\ref{prod:SwitchLabel}) \\
                     \| \xcd"default" \xcd":" \\
\end{bbgrammar}
%##)

A switch statement evaluates an index expression and then branches to
a case whose value is equal to the value of the index expression.
If no such case exists, the switch branches to the 
\xcd"default" case, if any.

Statements in each case branch are evaluated in sequence.  At the
end of the branch, normal control-flow falls through to the next case, if
any.  To prevent fall-through, a case branch may be exited using
a \xcd"break" statement.

The index expression must be of type \xcd"Int".
Case labels must be of type \xcd"Int", \xcd`Byte`, or \xcd`Short`, 
and must be compile-time 
constants.  Case labels cannot be duplicated within the
\xcd"switch" statement.

\begin{ex}
In this \xcd`switch`, case \xcd`1` falls through to case \xcd`2`.  The
other cases are separated by \xcd`break`s.
%~~gen ^^^ Statements70
% package Statement.Case;
% class Example {
% def example(i : Int, println: (String)=>void) {
%~~vis
\begin{xten}
switch (i) {
  case 1n: println("one, and ");
  case 2n: println("two"); 
          break;
  case 3n: println("three");
          break;
  default: println("Something else");
           break;
}
\end{xten}
%~~siv
% } } 
%~~neg
\end{ex}

\section{While statement}
\index{while}

%##(WhileStatement
\begin{bbgrammar}
%(FROM #(prod:WhileStmt)#)
           WhileStmt \: \xcd"while" \xcd"(" Exp \xcd")" Stmt & (\ref{prod:WhileStmt}) \\
\end{bbgrammar}
%##)

A while statement evaluates a \xcd`Boolean`-valued condition and executes a
loop body if \xcd"true". If the loop body completes normally (either by
reaching the end or via a \xcd"continue" statement with the loop header as
target), the condition is reevaluated and the loop repeats if \xcd"true". If
the condition is \xcd"false", the loop exits.

\begin{ex}
A loop to execute the process in the Collatz conjecture (a.k.a. 3n+1 problem,
Ulam conjecture, Kakutani's problem, Thwaites conjecture, Hasse's algorithm,
and Syracuse problem) can be written as follows:
%~~gen ^^^ Statements80
% package Statements.AreFor.Flatements;
% class Example {
% def example(var n:Long) {
%~~vis
\begin{xten}
  while (n > 1) {
     n = (n % 2 == 1) ? 3*n+1 : n/2;
  }
\end{xten}
%~~siv
% } } 
%~~neg
\end{ex}
\section{Do--while statement}
\index{do}

%##(DoStatement
\begin{bbgrammar}
%(FROM #(prod:DoStmt)#)
              DoStmt \: \xcd"do" Stmt \xcd"while" \xcd"(" Exp \xcd")" \xcd";" & (\ref{prod:DoStmt}) \\
\end{bbgrammar}
%##)


A \Xcd{do-while} statement executes the loop body, and then evaluates a
\xcd`Boolean`-valued condition expression. If \xcd"true", the loop repeats.
Otherwise, the loop exits.


\section{For statement}
\index{for}

%##(ForStatement BasicForStatement ForInit ForUpdate StatementExpList EnhancedForStatement
\begin{bbgrammar}
%(FROM #(prod:ForStmt)#)
             ForStmt \: BasicForStmt & (\ref{prod:ForStmt}) \\
                     \| EnhancedForStmt \\
%(FROM #(prod:BasicForStmt)#)
        BasicForStmt \: \xcd"for" \xcd"(" ForInit\opt \xcd";" Exp\opt \xcd";" ForUpdate\opt \xcd")" Stmt & (\ref{prod:BasicForStmt}) \\
%(FROM #(prod:ForInit)#)
             ForInit \: StmtExpList & (\ref{prod:ForInit}) \\
                     \| LocVarDecln \\
%(FROM #(prod:ForUpdate)#)
           ForUpdate \: StmtExpList & (\ref{prod:ForUpdate}) \\
%(FROM #(prod:StmtExpList)#)
         StmtExpList \: StmtExp & (\ref{prod:StmtExpList}) \\
                     \| StmtExpList \xcd"," StmtExp \\
%(FROM #(prod:EnhancedForStmt)#)
     EnhancedForStmt \: \xcd"for" \xcd"(" LoopIndex \xcd"in" Exp \xcd")" Stmt & (\ref{prod:EnhancedForStmt}) \\
                     \| \xcd"for" \xcd"(" Exp \xcd")" Stmt \\
\end{bbgrammar}
%##)

\xcd`for` statements provide bounded iteration, such as looping over a list.
It has two forms: a basic form allowing near-arbitrary iteration, {\em a la}
C, and an enhanced form designed to iterate over a collection.

A basic \xcd`for` statement provides for arbitrary iteration in a somewhat
more organized fashion than a \xcd`while`.  The loop 
\xcd`for(init; test; step)body` is
similar to: 
\begin{xten}
{
   init;
   while(test) {
      body;
      step;
   }
}
\end{xten}
\noindent
except that \xcd`continue` statements which continue the \xcd`for` loop will
perform the \xcd`step`, which, in the \xcd`while` loop, they will not do. 

\xcd`init` is performed before the loop, and is traditionally used to declare
and/or initialize the loop variables. It may be a single variable binding
statement, such as \xcd`var i:Long = 0` or \xcd`var i:Long=0, j:Long=100`. (Note
that a single variable binding statement may bind multiple variables.)
Variables introduced by \xcd`init` may appear anywhere in the \xcd`for`
statement, but not outside of it.  Or, it may be a sequence of expression
statements, such as \xcd`i=0, j=100`, operating on already-defined variables.
If omitted, \xcd`init` does nothing.

\xcd`test` is a Boolean-valued expression; an iteration of the loop will only
proceed if \xcd`test` is true at the beginning of the loop, after \xcd`init`
on the first iteration or after \xcd`step` on later ones. If omitted, \xcd`test`
defaults to \xcd`true`, giving a loop that will run until stopped by some
other means such as \xcd`break`, \xcd`return`, or \xcd`throw`.

\xcd`step` is performed after the loop body, between one iteration and the
next. It traditionally updates the loop variables from one iteration to the
next: \eg, \xcd`i++` and \xcd`i++,j--`.  If omitted, \xcd`step` does nothing.

\xcd`body` is a statement, often a code block, which is performed whenever
\xcd`test` is true.  If omitted, \xcd`body` does nothing.




\label{ForAllLoop}


An enhanced for statement is used to iterate over a collection, or other
structure designed to support iteration by implementing the interface
\xcd`Iterable[T]`.    The loop variable must be of type \xcd`T`, 
or destructurable from a value of type \xcd`T`
(\Sref{exploded-syntax}).  
Each iteration of the loop
binds the iteration variable to another element of the collection.
The loop \xcd`for(x in c)S` behaves like: 
%~~gen ^^^ Statements5e4u
% package Statements5e4u;
% class ForAll {
% def forall[T](c:Iterable[T], S: () => void) {
%~~vis
\begin{xten}
val iterator: Iterator[T] = c.iterator();
while (iterator.hasNext()) {
  val x : T = iterator.next();
  S();
}
\end{xten}
%~~siv
%} }
%~~neg

A number of library classes implement \xcd`Iterable`, and thus can be iterated
over.  For example, iterating over a \xcd`Rail` iterates the elements 
stored in the rail.

The type of the loop variable may be supplied as \xcd`x <: T`.  In this case
the iterable \xcd`c` must have type \xcd`Iterable[U}` for some \xcd`U <: T`,
and \xcd`x` will be given the type \xcd`U`.

\begin{ex}
This loop adds up the elements of a \xcd`List[Long]`.
Note that iterating over a list yields the elements of the list, as specified
in the \xcd`List` API. 
%~~gen ^^^ Statements3d9l
% package Statements3d9l;
% class Example {
%~~vis
\begin{xten}
static def sum(a:x10.util.List[Long]):Long {
  var s : Long = 0;
  for(x in a) s += x;
  return s;
}
\end{xten}
%~~siv
%}
%~~neg

The following code sums the elements of an integer rail. 
%~~gen ^^^ Statements2d4h
% package Statements2d4h;
% class Example { 
%~~vis
\begin{xten}
static def sum(a: Rail[Long]): Long {
  var s : Long = 0;
  for(v in a) s += v;
  return s;
}
\end{xten}
%~~siv
%}
%~~neg

Iteration over a \xcd`LongRange` is quite common. This
allows looping while varying a long index: 
%~~gen ^^^ Statements3o9s
% package Statements3o9s;
% class Example { static def example() {
%~~vis
\begin{xten}
var sum : Long = 0;
for(i in 1..10) sum += i;
assert sum == 55;
\end{xten}
%~~siv
%} } 
% class Hook { def run() { Example.example(); return true; } }
%~~neg


\end{ex}

Iteration variables have the \xcd`for` statement as scope.  They shadow other
variables of the same names.


\section{Return statement}
\label{ReturnStatement}
\index{return}

%##(ReturnStatement
\begin{bbgrammar}
%(FROM #(prod:ReturnStmt)#)
          ReturnStmt \: \xcd"return" Exp\opt \xcd";" & (\ref{prod:ReturnStmt}) \\
\end{bbgrammar}
%##)

Methods and closures may return values using a \xcd`return` statement. 
\xcd"void" methods must return without a value; other methods must return a value of the return type. 

\begin{ex}
The following code illustrates returning values from a closure and a method.
The \xcd`return` inside of \xcd`closure` returns from \xcd`closure`, not from
\xcd`method`.  
%~~gen ^^^ Statements2j1d
% package Statements2j1d;
% class Example {
%~~vis
\begin{xten}
def method(x:Long) {
  val closure = (y:Long) => {return x+y;}; 
  val res = closure(0);
  assert res == x;
  return res == x;
}
\end{xten}
%~~siv
%}
%~~neg


\end{ex}


\section{Assert statement} 
\index{assert}

%##(AssertStatement
\begin{bbgrammar}
%(FROM #(prod:AssertStmt)#)
          AssertStmt \: \xcd"assert" Exp \xcd";" & (\ref{prod:AssertStmt}) \\
                     \| \xcd"assert" Exp  \xcd":" Exp  \xcd";" \\
\end{bbgrammar}
%##)

The statement \xcd`assert E` checks that the Boolean expression \xcd`E`
evaluates to true, and, if not, throws an \xcd`x10.lang.Error`  exception.  
The annotated assertion statement \xcd`assert E : F;` checks \xcd`E`, and, if
it is 
false, throws an \xcd`x10.lang.Error` exception with \xcd`F`'s value attached
to it. 

\begin{ex}
The following code compiles properly.  
%~~gen ^^^ Statements100
% package Statements.Assert;
% 
%~~vis
\begin{xten}
class Example {
  public static def main(argv:Rail[String]) {
    val a = 1;
    assert a != 1 : "Changed my mind about a.";
  }
}
\end{xten}
%~~siv
%~~neg
\noindent
However, when run, it 
prints a stack trace starting with 
\begin{xten}
x10.lang.Error: Changed my mind about a.
\end{xten}
\end{ex}

\section{Exceptions in X10}
\index{exception}
\index{termination!abrupt}
\index{termination!normal}

X10 programs can throw {\em exceptions} to indicate unusual or problematic
situations; this is {\em abrupt termination}.  Exceptions, as data values, are
instances of \xcd`x10.lang.CheckedThrowable` or its subclasses. Note
that for ease of implementation X10 does not permit subclasses of
\xcd`x10.lang.CheckedThrowable` to be generic, that is, take type
parameters.   

Exceptions may be thrown intentionally with the
\xcd`throw` statement. Many primitives and library functions throw exceptions
if they encounter problems; \eg, dividing by zero throws an instance of
\xcd`x10.lang.ArithmeticException`. 

When an exception is thrown, dynamically enclosing
\xcd`try`-\xcd`catch` blocks in the same activity can attempt to handle it.   If the throwing
statement in inside some \xcd`try` clause, and some matching \xcd`catch`
clause catches that type of exception, the corresponding \xcd`catch` body will
be executed, and the process of throwing is finished.  
If no statically-enclosing \xcd`try`-\xcd`catch` block can handle the
exception, the current method call returns (abnormally), throwing the same
exception from the point at which the method was called.  

This process continues until the exception is handled or there are no more
calling methods in the activity. In the latter case, the activity will
terminate abnormally, and the exception will propagate to the activity's root;
see \Sref{ExceptionModel} for details.

\Xten{} supports both {\em checked} and {\em unchecked}
exceptions. Methods are obligated to declare via a \xcd{throws} clause
any checked exceptions that they might throw.  However, in 
\Xten{}, the class library design favors unchecked exceptions:
virtually all exceptions in the standard library are unchecked.  Checked
exceptions are defined to be any subclass of
\xcd{x10.lang.CheckedThrowable} that are not also subclasses of
either \xcd{x10.lang.Exception} or \xcd{x10.lang.Error}. All of the
concrete exception classes in the \Xten{} standard library are
subclasses of either \xcd{Exception} or \xcd{Error}.


\section{Throw statement}
\index{throw}

%##(ThrowStatement
\begin{bbgrammar}
%(FROM #(prod:ThrowStmt)#)
           ThrowStmt \: \xcd"throw" Exp \xcd";" & (\ref{prod:ThrowStmt}) \\
\end{bbgrammar}
%##)

\index{Exception}
\xcd"throw E" throws an exception whose value is \xcd`E`, which must be an
instance of a subtype of \xcd`x10.lang.CheckedThrowable`. 

\begin{ex}
The following code checks if an index is in range and
throws an exception if not.

%~~gen ^^^ Statements110
% package Statements_index_check;
% class ThrowStatementExample {
% def thingie(i:Long, x:Rail[Boolean])  {
%~~vis
\begin{xten}
if (i < 0 || i >= x.size)
    throw new MyIndexOutOfBoundsException();
\end{xten}
%~~siv
%} }
% class MyIndexOutOfBoundsException extends Exception {}
%~~neg
\end{ex}

\section{Try--catch statement}
\index{try}
\index{catch}
\index{finally}
\index{exception}

%##(TryStatement Catches CatchClause Finally
\begin{bbgrammar}
%(FROM #(prod:TryStmt)#)
             TryStmt \: \xcd"try" Block Catches & (\ref{prod:TryStmt}) \\
                     \| \xcd"try" Block Catches\opt Finally \\
%(FROM #(prod:Catches)#)
             Catches \: CatchClause & (\ref{prod:Catches}) \\
                     \| Catches CatchClause \\
%(FROM #(prod:CatchClause)#)
         CatchClause \: \xcd"catch" \xcd"(" Formal \xcd")" Block & (\ref{prod:CatchClause}) \\
%(FROM #(prod:Finally)#)
             Finally \: \xcd"finally" Block & (\ref{prod:Finally}) \\
\end{bbgrammar}
%##)

Exceptions are handled with a \xcd"try" statement.
A \xcd"try" statement consists of a \xcd"try" block, zero or more
\xcd"catch" blocks, and an optional \xcd"finally" block.

First, the \xcd"try" block is evaluated.  If the block throws an
exception, control transfers to the first matching \xcd"catch"
block, if any.  A \xcd"catch" matches if the value of the
exception thrown is a subclass of the \xcd"catch" block's formal
parameter type.

The \xcd"finally" block, if present, is evaluated on all normal
and exceptional control-flow paths from the \xcd"try" block.
If the \xcd"try" block completes normally
or via a \xcd"return", a \xcd"break", or a
\xcd"continue" statement, 
the \xcd"finally"
block is evaluated, and then control resumes at
the statement following the \xcd"try" statement, at the branch target, or at
the caller as appropriate.
If the \xcd"try" block completes
exceptionally, the \xcd"finally" block is evaluated after the
matching \xcd"catch" block, if any, and when and if the \xcd`finally` block
finishs normally, the
exception is rethrown.


The parameter of a \xcd`catch` block has the block as scope.  It shadows other
variables of the same name.

\begin{ex}
The \xcd`example()` method below executes without any assertion errors
%~~gen ^^^ Statements9x3m
% package Statements9x3m;
% 
%~~vis
\begin{xten}
class Example {
  class ThisExn extends Exception {}
  class ThatExn extends Exception {}
  var didFinally : Boolean = false;
  def example(b:Boolean) {
    try {
       throw b ? new ThatExn() : new ThisExn();
    }
    catch(ThatExn) {return true;}
    catch(ThisExn) {return false;}
    finally {
       this.didFinally = true;
    }
  }
  static def doExample() {
    val e = new Example();
    assert e.example(true);
    assert e.didFinally == true;
  }
}
\end{xten}
%~~siv
% 
% class Hook { def run() { Example.doExample(); return true; } }
%~~neg

\end{ex}

\limitation{Constraints on exception types in \xcd`catch` blocks are not
currently supported. 
}

\section{Assert}

The \xcd`assert` statement 
%~~stmt~~`~~`~~B:Boolean ~~
\xcd`assert B;` 
checks that the Boolean expression \xcd`B` evaluates to true.  If so,
computation proceeds.  If not, it throws \xcd`x10.lang.AssertionError`.

The extended form 
%~~stmt~~`~~`~~B:Boolean, A:Any ~~ 
\xcd`assert B:A;`
is similar, but provides more debugging information.  The value of the
expression \xcd`A` is available as part of the \xcd`AssertionError`, \eg, to
be printed on the console.

\begin{ex}
\xcd`assert` is useful for confirming properties that you believe to be true
and wish to rely on.  In particular, well-chosen \xcd`assert`s make a program
robust in the face of code changes and unexpected uses of methods.
For example, the following method compute percent differences, but asserts
that it is not dividing by zero.  If the mean is zero, it throws an exception,
including the values of the numbers as potentially useful debugging
information. 
%~~gen ^^^ StmtAssert10
%package StmtAssert10;
% class Example {
%~~vis
\begin{xten}
static def percentDiff(x:Double, y:Double) {
  val diff = x-y;
  val mean = (x+y)/2;
  assert mean != 0.0  : [x,y]; 
  return Math.abs(100 * (diff / mean));
}
\end{xten}
%~~siv
% }
%~~neg

\end{ex}


At times it may be considered important not to check \xcd`assert` statements;
\eg, if the test is expensive and the code is sufficiently well-tested.  The
\xcd`-noassert` command line option causes the compiler to ignore all
\xcd`assert` statements. 


\section{User-Defined Control Structures}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\vardecl}[2]{\ensuremath{{#1}\texttt{:}{#2}}}

% userEnhancedForStatement:
%       userStatementPrefix kw='for' typeArgumentsopt '(' formalParameterList 'in' argumentListopt ')' closureBodyBlock
%     | userStatementPrefix kw='for' typeArgumentsopt '(' argumentListopt ')' closureBodyBlock
%     ;
\newcommand{\usrFor}[5]{\ensuremath{{#1}\texttt{.for}\texttt{[}{#2}\texttt{]}^?\texttt{(}({#3}\texttt{~in})^?~{#4}\texttt{)~}{#5}}}
\newcommand{\libFor}[5]{\ensuremath{{#1}\texttt{.operator~for}\texttt{[}{#2}\texttt{]}^?\texttt{(}{#4}\texttt{,}~\texttt{(}{#3}^?\texttt{)}~\texttt{=>}~{#5}\texttt{);}}}

% userIfThenStatement:
%       userStatementPrefix kw='if' typeArgumentsopt '(' argumentListopt ')' s1=closureBodyBlock ('else' s2=closureBodyBlock)?
\newcommand{\usrIf}[5]{\ensuremath{{#1}\texttt{.if}\texttt{[}{#2}\texttt{]}^?\texttt{(}{#3}\texttt{)~}{#4}~(\texttt{else~}{#5})^?}}
\newcommand{\libIf}[5]{\ensuremath{{#1}\texttt{.operator~if}\texttt{[}{#2}\texttt{]}^?\texttt{(}{#3}\texttt{,}~%
    \texttt{()=>}~{#4}(\texttt{,}~%
    \texttt{()}\texttt{=>}~{#5})^?\texttt{);}}}


% userTryStatement:
%       userStatementPrefix kw='try' typeArgumentsopt argumentsopt closureBodyBlock userCatchesopt userFinallyBlock?
% userCatches returns [List<Closure> ast]:
%       userCatchClause+
% userCatchClause returns [Closure ast]:
%       'catch' '(' formalParameterListopt ')' closureBodyBlock
% userFinallyBlock returns [Closure ast]:
%       'finally' closureBodyBlock
\newcommand{\usrTry}[7]{\ensuremath{{#1}\texttt{.try}\texttt{[}{#2}\texttt{]}^?\texttt{(}{#3}\texttt{)}^?~{#4}\texttt{~catch~(}{#5}\texttt{)~}{#6}~(\texttt{finally~}{#7})^?}}
\newcommand{\libTry}[7]{\ensuremath{{#1}\texttt{.operator~try}\texttt{[}{#2}\texttt{]}^?\texttt{(}%
    ({#3}\texttt{,})^?~%
    \texttt{()=>}~{#4}\texttt{,}~%
    \texttt{(}{#5}\texttt{)}~\texttt{=>}~{#6}(\texttt{,}~%
    \texttt{()=>}~{#7})^?\texttt{);}}}

% userThrowStatement:
%       userStatementPrefix kw='throw' typeArgumentsopt expressionopt ';'
\newcommand{\usrThrow}[3]{\ensuremath{{#1}\texttt{.throw}\texttt{[}{#2}\texttt{]}^?~{#3}^?\texttt{;}}}
\newcommand{\libThrow}[3]{\ensuremath{{#1}\texttt{.operator throw}\texttt{[}{#2}\texttt{]}^?\texttt{(}{#3}^?\texttt{);}}}

% userAsyncStatement:
%       userStatementPrefix kw='async' typeArgumentsopt argumentsopt clockedClauseopt closureBodyBlock
% clockedClauseopt:
%       ('clocked' arguments)?
\newcommand{\usrAsync}[5]{\ensuremath{{#1}\texttt{.async}\texttt{[}{#2}\texttt{]}^?\texttt{(}{#3}\texttt{)}^?~(\texttt{clocked~(}{#4}\texttt{)})^?~{#5}}}
\newcommand{\libAsync}[5]{\ensuremath{{#1}\texttt{.operator~async}\texttt{[}{#2}\texttt{]}^?\texttt{(}%
    ({#3}\texttt{,})^?~%
    ({#4}\texttt{,})^?~%
    \texttt{()=>}~{#5}\texttt{);}}}

% userAtomicStatement:
%       userStatementPrefix kw='atomic' typeArgumentsopt argumentsopt closureBodyBlock
\newcommand{\usrAtomic}[4]{\ensuremath{{#1}\texttt{.atomic}\texttt{[}{#2}\texttt{]}^?\texttt{(}{#3}\texttt{)}^?~{#4}}}
\newcommand{\libAtomic}[4]{\ensuremath{{#1}\texttt{.operator~atomic}\texttt{[}{#2}\texttt{]}^?\texttt{(}%
    ({#3}\texttt{,})^?~%
    \texttt{()=>}~{#4}\texttt{);}}}

% userWhenStatement:
%       userStatementPrefix kw='when' typeArgumentsopt '(' argumentListopt ')' closureBodyBlock
\newcommand{\usrWhen}[4]{\ensuremath{{#1}\texttt{.when}\texttt{[}{#2}\texttt{]}^?\texttt{(}{#3}\texttt{)~}{#4}}}
\newcommand{\libWhen}[4]{\ensuremath{{#1}\texttt{.operator~when}\texttt{[}{#2}\texttt{]}^?\texttt{(}%
    {#3}\texttt{,}~%
    \texttt{()=>}~{#4}\texttt{);}}}

% userFinishStatement:
%       userStatementPrefix kw='finish' typeArgumentsopt argumentsopt closureBodyBlock
\newcommand{\usrFinish}[4]{\ensuremath{{#1}\texttt{.finish}\texttt{[}{#2}\texttt{]}^?\texttt{(}{#3}\texttt{)}^?~{#4}}}
\newcommand{\libFinish}[4]{\ensuremath{{#1}\texttt{.operator~finish}\texttt{[}{#2}\texttt{]}^?\texttt{(}%
    ({#3}\texttt{,})^?~%
    \texttt{()=>}~{#4}\texttt{);}}}

% userAtStatement:
%       userStatementPrefix kw='at' typeArgumentsopt '(' argumentListopt ')' closureBodyBlock
\newcommand{\usrAt}[4]{\ensuremath{{#1}\texttt{.at}\texttt{[}{#2}\texttt{]}^?\texttt{(}{#3}\texttt{)~}{#4}}}
\newcommand{\libAt}[4]{\ensuremath{{#1}\texttt{.operator~at}\texttt{[}{#2}\texttt{]}^?\texttt{(}%
    {#3}\texttt{,}~%
    \texttt{()=>}~{#4}\texttt{);}}}

% userContinueStatement:
%       userStatementPrefix kw='continue' typeArgumentsopt expressionopt ';'
\newcommand{\usrContinue}[3]{\ensuremath{{#1}\texttt{.continue}\texttt{[}{#2}\texttt{]}^?~{#3}^?\texttt{;}}}
\newcommand{\libContinue}[3]{\ensuremath{{#1}\texttt{.operator continue}\texttt{[}{#2}\texttt{]}^?\texttt{(}{#3}^?\texttt{);}}}

% userBreakStatement:
%       userStatementPrefix kw='break' typeArgumentsopt expressionopt ';'
\newcommand{\usrBreak}[3]{\ensuremath{{#1}\texttt{.break}\texttt{[}{#2}\texttt{]}^?~{#3}^?\texttt{;}}}
\newcommand{\libBreak}[3]{\ensuremath{{#1}\texttt{.operator break}\texttt{[}{#2}\texttt{]}^?\texttt{(}{#3}^?\texttt{);}}}

% userAtEachStatement:
%       userStatementPrefix kw='ateach' typeArgumentsopt '(' formalParameterList 'in' argumentListopt ')' closureBodyBlock
%     | userStatementPrefix kw='ateach' typeArgumentsopt '(' argumentListopt ')' closureBodyBlock
\newcommand{\usrAteach}[5]{\ensuremath{{#1}\texttt{.ateach}\texttt{[}{#2}\texttt{]}^?\texttt{(}({#3}\texttt{~in})^?~{#4}\texttt{)~}{#5}}}
\newcommand{\libAteach}[5]{\ensuremath{{#1}\texttt{.operator~ateach}\texttt{[}{#2}\texttt{]}^?\texttt{(}{#4}\texttt{,}~\texttt{(}{#3}^?\texttt{)}~\texttt{=>}~{#5}\texttt{);}}}

% userWhileStatement:
%       userStatementPrefix kw='while' typeArgumentsopt '(' argumentListopt ')' closureBodyBlock
\newcommand{\usrWhile}[4]{\ensuremath{{#1}\texttt{.while}\texttt{[}{#2}\texttt{]}^?\texttt{(}{#3}\texttt{)~}{#4}}}
\newcommand{\libWhile}[4]{\ensuremath{{#1}\texttt{.operator~while}\texttt{[}{#2}\texttt{]}^?\texttt{(}%
    {#3}\texttt{,}~%
    \texttt{()=>}~{#4}\texttt{);}}}

% userDoStatement:
%       userStatementPrefix kw='do' typeArgumentsopt closureBodyBlock 'while' '(' argumentListopt ')' ';'
\newcommand{\usrDo}[4]{\ensuremath{{#1}\texttt{.do}\texttt{[}{#2}\texttt{]}^?~{#3}\texttt{~while~(}{#4}\texttt{);}}}
\newcommand{\libDo}[4]{\ensuremath{{#1}\texttt{.operator~do}\texttt{[}{#2}\texttt{]}^?\texttt{(}%
    \texttt{()=>}~{#3}\texttt{,}~%
    {#4}\texttt{);}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

$$
\begin{array}{lcl}
  KeywordOpDecln & ::= &
  \\
  \multicolumn{3}{l}{\qquad
  MethMods\ \mathtt{operator}\ keywordOp\ TypeParams^?\ Formals\ Guard^?\ Throws^?
  }\\
  \multicolumn{3}{l}{\qquad
  HasResultType^?\ MethodBody
  }\\
  keywordOp & ::= &
      \mathtt{for}
    | \mathtt{if}
    | \mathtt{try}
    | \mathtt{throw}
    | \mathtt{async}
    | \mathtt{atomic}
    | \mathtt{when}
    | \mathtt{finish}
    | \mathtt{at}
  \\ &&
    | \mathtt{continue}
    | \mathtt{break}
    | \mathtt{ateach}
    | \mathtt{while}
    | \mathtt{do}
    % | \mathtt{return}
\end{array}
$$

Similarly to user-defined operators, it is possible to redefine the
behavior of some control structures.
%
For example, suppose that we want to define a \verb+if+ statement that
randomly chooses which branch to execute. In a class \verb+RandomIf+,
we define a method named \verb+if+~(introduced with the keyword
\verb+operator+) that implements this behavior:
\begin{verbatim}
class RandomIf {
    val random = new Random();
    public operator if(then: ()=>void, else_: ()=>void) {
        if (random.nextBoolean()) {
            then();
        } else {
            else_();
        }
    }
}
\end{verbatim}
Then, we can call this method using the syntax of the \verb+if+
statement by prefixing the \verb+if+ keyword by an object that
implements this method:
\begin{verbatim}
    val random = new RandomIf();
    random.if () {
        Console.OUT.println("true");
    } else {
        Console.OUT.println("false");
    }
\end{verbatim}
The blocks that represent the \verb+then+ and the \verb+else+ branches
of the \verb+if+ are automatically turned into closures and are given
as argument to the \verb+RandomIf.if+ method.

To distinguish the use of a user-defined control structure from the
use of a built-in one, the first keyword of the control structure must
be prefixed with the object that redefines its behavior.
%
The scoping and dispatching rules of user-defined control structures
is exactly the same as the one of methods.


User-defined control structures can also be called as standard methods
using the \verb+operator+ prefix~(as for user-defined operators). For
example, the previous code is equivalent to:
\begin{verbatim}
    val random = new RandomIf();
    random.operator if (() => { Console.OUT.println("true"); },
                        () => { Console.OUT.println("false"); });
\end{verbatim}


\begin{figure}[t]
  \centering
  $$
  \begin{array}{l}
    \usrIf{o}{\overline{T}}{\overline{e}}{b_1}{b_2}
    \equiv
    \\
    \qquad\qquad
    \libIf{o}{\overline{T}}{\overline{e}}{b_1}{b_2}
    \\

    \usrFor{o}{\overline{T}}{\overline{\vardecl{x}{t}}}{\overline{e}}{b}
    \equiv
    \\
    \qquad\qquad
    \libFor{o}{\overline{T}}{\overline{\vardecl{x}{t}}}{\overline{e}}{b}
    \\

    \usrTry{o}{\overline{T}}{\overline{e}}{b_1}{\overline{\vardecl{x}{t}}}{b_2}{b_3}
    \equiv
    \\
    \qquad\qquad
    \libTry{o}{\overline{T}}{\overline{e}}{b_1}{\overline{\vardecl{x}{t}}}{b_2}{b_3}
    \\

    \usrThrow{o}{\overline{T}}{e}
    \equiv
    \libThrow{o}{\overline{T}}{e}
    \\

    \usrAsync{o}{\overline{T}}{\overline{e_1}}{\overline{e_2}}{b}
    \equiv
    \\
    \qquad\qquad
    \libAsync{o}{\overline{T}}{\overline{e_1}}{\overline{e_2}}{b}
    \\

    \usrAtomic{o}{\overline{T}}{\overline{e}}{b}
    \equiv
    \libAtomic{o}{\overline{T}}{\overline{e}}{b}
    \\

    \usrWhen{o}{\overline{T}}{\overline{e}}{b}
    \equiv
    \libWhen{o}{\overline{T}}{\overline{e}}{b}
    \\

    \usrFinish{o}{\overline{T}}{\overline{e}}{b}
    \equiv
    \libFinish{o}{\overline{T}}{\overline{e}}{b}
    \\

    \usrAt{o}{\overline{T}}{\overline{e}}{b}
    \equiv
    \libAt{o}{\overline{T}}{\overline{e}}{b}
    \\

    \usrContinue{o}{\overline{T}}{e}
    \equiv
    \libContinue{o}{\overline{T}}{e}
    \\

    \usrBreak{o}{\overline{T}}{e}
    \equiv
    \libBreak{o}{\overline{T}}{e}
    \\

    \usrAteach{o}{\overline{T}}{\overline{\vardecl{x}{t}}}{\overline{e}}{b}
    \equiv
    \\
    \qquad\qquad
    \libAteach{o}{\overline{T}}{\overline{\vardecl{x}{t}}}{\overline{e}}{b}
    \\

    \usrWhile{o}{\overline{T}}{\overline{e}}{b}
    \equiv
    \libWhile{o}{\overline{T}}{\overline{e}}{b}
    \\

    \usrDo{o}{\overline{T}}{b}{\overline{e}}
    \equiv
    \libDo{o}{\overline{T}}{b}{\overline{e}}
    \\

\end{array}
$$
  \caption{Correspondence between control structure and method call notations.}
  \label{fig:trans}
\end{figure}

The correspondence between the two invocation syntaxes is formally
specified in Figure~\ref{fig:trans} for all the control structures we
support.
%
It uses the following conventions:
%
$o$ is either a class path or an object;
%
$\overline{T}$ is a list of types;
%
$\overline{\vardecl{x}{t}}$
is a list of variable declaration with their types;
%
$\overline{e}$ is a list of expressions;
%
$b$
is a closure body: a list of statements between curly braces that can
optionally end with an expression~(a return value);
%
$(\,)^?$ is an optional group.

The rule for \verb+if+ is:
$$
\begin{array}{rcl}
  \usrIf{o}{\overline{T}}{\overline{e}}{b_1}{b_2}
  & \equiv &
  \\
  \multicolumn{3}{r}{
  \qquad\libIf{o}{\overline{T}}{\overline{e}}{b_1}{b_2}}
\end{array}
$$
Compared to the builtin \verb+if+ control structure, the user-defined one accepts type arguments and replaces one condition expression with a list of expressions, possibly empty.
The branches of the user-defined \verb+if+ statement are lifted to no-arg closures and passed to the user-defined \verb+if+ method as arguments. 
 The \verb+else+ branch is optional.

The correspondence is purely syntactic. In other words, the control structure syntax is simply rewritten into the regular method invocation syntax with no consideration of types or method lookup.

\subsection{User-Defined \texttt{for}}

% {\scriptsize
% \begin{verbatim}
% userEnhancedForStatement ::=
%     fullyQualifiedName '.' 'for' typeArgumentsopt '(' loopIndex 'in' expression ')' closureBodyBlock
%   | primary '.' 'for' typeArgumentsopt '(' loopIndex 'in' expression ')' closureBodyBlock
%   | 'super' '.' 'for' typeArgumentsopt '(' loopIndex 'in' expression ')' closureBodyBlock
%   | className '.' 'super' '.' 'for' typeArgumentsopt '(' loopIndex 'in' expression ')' closureBodyBlock
%   | fullyQualifiedName '.' 'for' typeArgumentsopt '(' expression ')' closureBodyBlock
%   | primary '.' 'for' typeArgumentsopt '(' expression ')' closureBodyBlock
%   | 'super' '.' 'for' typeArgumentsopt '(' expression ')' closureBodyBlock
%   | className '.' 'super' '.' 'for' typeArgumentsopt '(' expression ')' closureBodyBlock
%   ;
% \end{verbatim}
% }

$$
\begin{array}{rcl}
  \usrFor{o}{\overline{T}}{\overline{\vardecl{x}{t}}}{\overline{e}}{b}
  & \equiv &
  \\
  \multicolumn{3}{r}{
  \qquad  \libFor{o}{\overline{T}}{\overline{\vardecl{x}{t}}}{\overline{e}}{b}
  }
\end{array}
$$

A \verb+for+ loop over a collection may be defined in a container \verb+A+ as:
\begin{verbatim}
operator for[T](c: Iterable[T], body: (T)=>void) = ...
\end{verbatim}
%
The use of such user-defined \verb+for+ loop would have the following form:
\begin{verbatim}
A.for (x: T in c) { ... }
\end{verbatim}
and would correspond to the following method call:
\begin{verbatim}
A.operator for (c, (x: Long) => { ... });
\end{verbatim}
%
The body of the \verb+for+ is automatically translated into a closure
that takes the iteration variable as parameter.
%
Since there is no type inference for closure parameters, the type of
the iteration variable must be given explicitly.

The second argument of a \verb+for+ method can be a closure without argument:
\begin{verbatim}
operator for[T](c: Iterable[T], body: ()=>void) = ...
\end{verbatim}
In this case, the method is called using the syntax of a \verb+for+ loop without iteration variable:
\begin{verbatim}
A.for (c) { ... }
\end{verbatim}

\begin{example}
  A naive implementation of a parallel loop can be:
\begin{verbatim}
class Parallel {

  public static operator for[T](c: Iterable[T], body: (T)=>void) {
    finish {
      for(x in c) {
        async { body(x); }
      }
    }
  }

  public static def main(Rail[String]) {
    val cpt = new Cell[Long](0);
    Parallel.for(i:Long in 1..10) {
      atomic { cpt() = cpt() + i; }
    }
    Console.OUT.println(cpt());
  }
}
\end{verbatim}
\end{example}

\begin{example}
  We can also use the user-defined \verb+for+ loops to define
  iterations over a two dimensional space. Let define a loop that
  creates an activity for each element of the first dimension.
\begin{verbatim}
class Parallel2 {
  public static operator for (space: DenseIterationSpace_2,
                              body: (i:Long, j:Long)=>void) {
    finish {
      for (i in space.min0 .. space.max0) {
        async for (j in space.min1 .. space.max1) {
          body(i, j);
        }
      }
    }
  }
}
\end{verbatim}
and it can be used as follows:
\begin{verbatim}
Parallel2.for (i:Long, j:Long in 1..10 * 1..10) { ... }
\end{verbatim}
The list of variables before the \verb+in+ keyword becomes the
parameters of the closure whose body is the body of the loop.
\end{example}

\subsection{User-Defined \texttt{if}}
% {\scriptsize
% \begin{verbatim}
% userIfThenStatement ::=
%     fullyQualifiedName '.' 'if' typeArgumentsopt '(' argumentListopt ')' closureBodyBlock ('else' closureBodyBlock)?
%   | primary '.' 'if' typeArgumentsopt '(' argumentListopt ')' closureBodyBlock ('else' closureBodyBlock)?
%   | 'super' '.' 'if' typeArgumentsopt '(' argumentListopt ')' closureBodyBlock ('else' closureBodyBlock)?
%   | className '.'  'super' '.' 'if' typeArgumentsopt '(' argumentListopt ')' closureBodyBlock ('else' closureBodyBlock)?
%   ;
% \end{verbatim}
% }

$$
\begin{array}{rcl}
  \usrIf{o}{\overline{T}}{\overline{e}}{b_1}{b_2}
  & \equiv &
  \\
  \multicolumn{3}{r}{
  \qquad  \libIf{o}{\overline{T}}{\overline{e}}{b_1}{b_2}
  }
\end{array}
$$

  When we use a user-defined \verb+if+ statement, the condition is
evaluated before calling the \verb+if+ method, but the then and else
branches are implicitly lifted to closures without argument.

Note that the condition of a user-defined \verb+if+ statement can take
an arbitrary number of arguments. This is why we were able to define the
\verb+Random.if+ that does not take a condition.


\subsection{User-Defined \texttt{try}}
% {\scriptsize
% \begin{verbatim}
% userTryStatement ::=
%     fullyQualifiedName '.' 'try' typeArgumentsopt closureBodyBlock userCatches
%   | primary '.' 'try' typeArgumentsopt closureBodyBlock userCatches
%   | 'super' '.' 'try' typeArgumentsopt closureBodyBlock userCatches
%   | className '.'  'super' '.' 'try' typeArgumentsopt closureBodyBlock userCatches
%   | fullyQualifiedName '.' 'try' typeArgumentsopt closureBodyBlock userCatchesopt userFinallyBlock
%   | primary '.' 'try' typeArgumentsopt closureBodyBlock userCatchesopt userFinallyBlock
%   | 'super' '.' 'try' typeArgumentsopt closureBodyBlock userCatchesopt userFinallyBlock
%   | className '.'  'super' '.' 'try' typeArgumentsopt closureBodyBlock userCatchesopt userFinallyBlock
%   ;
% userCatches ::=
%     userCatchClause+
%   ;
% userCatchClause ::=
%     'catch' '(' formalParameterListopt ')' closureBodyBlock
%   ;
% userFinallyBlock ::=
%     'finally' closureBodyBlock
%   ;
% \end{verbatim}
% }

$$
\begin{array}{rcl}
  \usrTry{o}{\overline{T}}{\overline{e}}{b_1}{\overline{\vardecl{x}{t}}}{b_2}{b_3}
  & \equiv &
  \\
\multicolumn{3}{r}{
 \qquad \libTry{o}{\overline{T}}{\overline{e}}{b_1}{\overline{\vardecl{x}{t}}}{b_2}{b_3}
}
\end{array}
$$

When we use a user-defined \verb+try+ statement, the body of the
\verb+try+ is lifted to a closure without argument and handler is
lifted to a closure that has the parameter of the \verb+catch+ as
parameter. The \verb+finally+ block is also lifted to a closure
without argument.


\begin{example}
  The user-defined \verb+try+ construct can be used to provide a
  control structure that automatically removes the nesting of
  \verb+MultipleExceptions+:
\begin{verbatim}
class Flatten {

  public static operator try(body:()=>void,
                             handler:(MultipleExceptions)=>void) {
    try { body(); }
    catch (me: MultipleExceptions) {
      val exns = new GrowableRail[CheckedThrowable]();
      flatten(me, exns);
      handler (new MultipleExceptions(exns));
    }
  }

  private static def flatten(me:MultipleExceptions,
                             acc:GrowableRail[CheckedThrowable]) {
    for (e in me.exceptions) {
      if (e instanceof MultipleExceptions) {
        flatten(e as MultipleExceptions, acc);
      } else {
        acc.add(e);
      }
    }
  }
}
\end{verbatim}

  Used in the following example, the \verb+MultipleExceptions+
  \verb+me+ contains the exceptions \verb+Exception("Exn 1")+,
  \verb+Exception("Exn 2")+, and \verb+Exception("Exn 3")+ instead of
  the exception \verb+Exception("Exn 1")+ and another
  \verb+MultipleExceptions+.
\begin{verbatim}
public static def main(Rail[String]) {
  Flatten.try {
    finish {
      async { throw new Exception("Exn 1"); }
      async finish {
        async { throw new Exception("Exn 2"); }
        async { throw new Exception("Exn 3"); }
      }
    }
  } catch (me: MultipleExceptions) {
    Console.OUT.println(me.exceptions);
  }
}
\end{verbatim}

\end{example}

\subsection{User-Defined \texttt{throw}}
% {\scriptsize
% \begin{verbatim}
% userThrowStatement ::=
%     fullyQualifiedName '.' 'throw' typeArgumentsopt expressionopt ';'
%   | primary '.' 'throw' typeArgumentsopt expressionopt ';'
%   | 'super' '.' 'throw' typeArgumentsopt expressionopt ';'
%   | className '.'  'super' '.' 'throw' typeArgumentsopt expressionopt ';'
%   ;
% \end{verbatim}
% }

$$
\begin{array}{rcl}
  \usrThrow{o}{\overline{T}}{e}
  & \equiv &
  \libThrow{o}{\overline{T}}{e}
\end{array}
$$
The argument of a user-defined \verb+throw+ is evaluated before
calling the \verb+throw+ method.


\subsection{User-Defined \texttt{async}}
% {\scriptsize
% \begin{verbatim}
% userAsyncStatement ::=
%     fullyQualifiedName '.' 'async' typeArgumentsopt clockedClauseopt closureBodyBlock
%   | primary '.' 'async' typeArgumentsopt clockedClauseopt closureBodyBlock
%   | 'super' '.' 'async' typeArgumentsopt clockedClauseopt closureBodyBlock
%   | className '.'  'super' '.' 'async' typeArgumentsopt clockedClauseopt closureBodyBlock
%   ;
% \end{verbatim}
% }
$$
\begin{array}{rcl}
  \usrAsync{o}{\overline{T}}{\overline{e_1}}{\overline{e_2}}{b}
  & \equiv &
  \libAsync{o}{\overline{T}}{\overline{e_1}}{\overline{e_2}}{b}
\end{array}
$$

The body of a user-defined \verb+async+ is lifted to a closure without
argument. The clock arguments are evaluated before the call to the
\verb+async+ method.

\begin{example}
  An \verb+async+ that does not execute in the scope in which it is
  written. The task is created in the scope where the object that
  defines the \verb+async+ method is instantiated.
\begin{verbatim}
class Escape {
  private var task: ()=>void = null;
  private var stop: Boolean = false;

  public def this() {
    async {
      while (!stop) {
        val t: () => void;
        when (task != null || stop) {
          t = task;
          task = null;
        }
        if (t != null) {
          async { t(); }
        }
      }
    }
  }

  public operator async (body: () => void) {
    when (task == null) {
      task = body;
    }
  }

  public def stop() {
    atomic { stop = true; }
  }
}
\end{verbatim}
  In the following example, the message \verb+"OK"+ is printed even if
  the created task never terminates because the task is executed
  outside of the scope of the \verb+finish+.
\begin{verbatim}
public static def main(Rail[String]) {
  val toplevel = new Escape();
  finish {
    toplevel.async { when (false){} }
  }
  Console.OUT.println("OK");
}
\end{verbatim}
\end{example}

\subsection{User-Defined \texttt{atomic}}
% {\scriptsize
% \begin{verbatim}
% userAtomicStatement ::=
%     fullyQualifiedName '.' 'atomic' typeArgumentsopt closureBodyBlock
%   | primary '.' 'atomic' typeArgumentsopt closureBodyBlock
%   | 'super' '.' 'atomic' typeArgumentsopt closureBodyBlock
%   | className '.'  'super' '.' 'atomic' typeArgumentsopt closureBodyBlock
%   ;
% \end{verbatim}
% }

$$
\begin{array}{rcl}
  \usrAtomic{o}{\overline{T}}{\overline{e}}{b}
  & \equiv &
  \libAtomic{o}{\overline{T}}{\overline{e}}{b}
\end{array}
$$

The body of a user-defined atomic statement is lifted to a closure without argument.

\subsection{User-Defined \texttt{when}}
% {\scriptsize
% \begin{verbatim}
% userWhenStatement ::=
%     fullyQualifiedName '.' 'when' typeArgumentsopt '(' argumentListopt ')' closureBodyBlock
%   | primary '.' 'when' typeArgumentsopt '(' argumentListopt ')' closureBodyBlock
%   | 'super' '.' 'when' typeArgumentsopt '(' argumentListopt ')' closureBodyBlock
%   | className '.'  'super' '.' 'when' typeArgumentsopt '(' argumentListopt ')' closureBodyBlock
%   ;
% \end{verbatim}
% }

$$
\begin{array}{rcl}
    \usrWhen{o}{\overline{T}}{\overline{e}}{b}
    & \equiv &
    \libWhen{o}{\overline{T}}{\overline{e}}{b}
\end{array}
$$

The arguments of a user-defined \verb+when+ statements are evaluated
before the call of the \verb+when+ method and the body is lifted to a
closure without argument. It means that if the argument of a
user-defined \verb+when+ is of type \verb+Boolean+, the condition is
evaluated once and cannot be changed. To be able to update the
condition, it can be an object with mutable field as in the following
example or a closure.


\begin{example}
  We can provide a \verb+when+ statement whose execution can be
  canceled while it is waiting:
\begin{verbatim}
class CancelableWhen {
  private var stop : Boolean = false;

  public operator when(condition:Cell[Boolean], body:()=>void) {
    when (condition() || stop) {
      if (!stop) { body(); }
    }
  }

  public def cancel() {
    atomic { stop = true; }
  }
}
\end{verbatim}
The following example will not print the message \verb+"KO"+ but will
terminate even if the condition \verb+b+ of the \verb+when+ remains
false:
\begin{verbatim}
public static def main(Rail[String]) {
  val c = new CancelableWhen();
  val b = new Cell[Boolean](false);
  finish {
    async {
      c.when(b) { Console.OUT.println("KO"); }
    }
    c.cancel();
  }
}
\end{verbatim}
\end{example}

\subsection{User-Defined \texttt{finish}}
% {\scriptsize
% \begin{verbatim}
% userFinishStatement ::=
%     fullyQualifiedName '.' 'finish' typeArgumentsopt closureBodyBlock
%   | primary '.' 'finish' typeArgumentsopt closureBodyBlock
%   | 'super' '.' 'finish' typeArgumentsopt closureBodyBlock
%   | className '.'  'super' '.' 'finish' typeArgumentsopt closureBodyBlock
%   ;
% \end{verbatim}
% }

$$
\begin{array}{rcl}
    \usrFinish{o}{\overline{T}}{\overline{e}}{b}
    & \equiv &
    \libFinish{o}{\overline{T}}{\overline{e}}{b}
\end{array}
$$

The body of a user-defined \verb+finish+ is lifted to a closure.

\begin{example}
  We define a \verb+finish+ that provide the ability to some parallel task to wait for its termination:
\begin{verbatim}
class SignalingFinish {
  private var terminated : Boolean = false;
  public operator finish(body: ()=>void) {
    finish {
      body();
    }
    atomic { terminated = true; }
  }
  public def join() {
    when (terminated) {}
  }
}
\end{verbatim}
  The following example will always print the message \verb+"before"+
  before the message \verb+"after"+.
\begin{verbatim}
public static def main(Rail[String]) {
  val t = new SignalingFinish();
  async {
    t.join();
    Console.OUT.println("after");
  }
  t.finish {
    Console.OUT.println("before");
  }
}
\end{verbatim}
\end{example}

\subsection{User-Defined \texttt{at}}
% {\scriptsize
% \begin{verbatim}
% userAtStatement ::=
%     fullyQualifiedName '.' 'at' typeArgumentsopt '(' argumentListopt ')' closureBodyBlock
%   | primary '.' 'at' typeArgumentsopt '(' argumentListopt ')' closureBodyBlock
%   | 'super' '.' 'at' typeArgumentsopt '(' argumentListopt ')' closureBodyBlock
%   | className '.'  'super' '.' 'at' typeArgumentsopt '(' argumentListopt ')' closureBodyBlock
%   ;
% \end{verbatim}
% }

$$
\begin{array}{rcl}
  \usrAt{o}{\overline{T}}{\overline{e}}{b}
  & \equiv &
  \libAt{o}{\overline{T}}{\overline{e}}{b}
\end{array}
$$

The arguments of the user-defined \verb+at+ statement are evaluated
before the call of the \verb+at+ method and the body of the statement
is lifted to a closure without argument.


\begin{example}
  We define a class \verb+Ring+ implementing an \verb+at+ statement
  without argument. Each call to this user-defined \verb+at+ statement
  moves the activity to the next place in the place group given when
  the object is instantiated.
\begin{verbatim}
class Ring {
  val places: PlaceGroup;

  public def this (places: PlaceGroup) {
    this.places = places;
  }

  public operator at(body: ()=>void) {
    at(places.next(here)) { body(); }
  }
}
\end{verbatim}

\begin{verbatim}
public static def main(Rail[String]) {
  val r = new Ring(Place.places());
  r.at() {
    Console.OUT.println("Hello from "+here+"!");
    r.at() {
      Console.OUT.println("Hello from "+here+"!");
    }
  }
}
\end{verbatim}
\end{example}


\subsection{User-Defined \texttt{ateach}}
% {\scriptsize
% \begin{verbatim}
% userateachStatement ::=
%     fullyQualifiedName '.' 'ateach' typeArgumentsopt '(' argumentListopt ')' closureBodyBlock
%   | primary '.' 'ateach' typeArgumentsopt '(' argumentListopt ')' closureBodyBlock
%   | 'super' '.' 'ateach' typeArgumentsopt '(' argumentListopt ')' closureBodyBlock
%   | className '.'  'super' '.' 'ateach' typeArgumentsopt '(' argumentListopt ')' closureBodyBlock
%   ;
% \end{verbatim}
% }

$$
\begin{array}{rcl}
  \usrAteach{o}{\overline{T}}{\overline{\vardecl{x}{t}}}{\overline{e}}{b}
  & \equiv &
  \\
  \multicolumn{3}{r}{
  \qquad  \libAteach{o}{\overline{T}}{\overline{\vardecl{x}{t}}}{\overline{e}}{b}
  }
\end{array}
$$

The arguments of the user-defined \verb+ateach+ statement are
evaluated before the call of the \verb+ateach+ method and the body of
the statement is lifted to a closure without argument.

\begin{example}
  An \verb+ateach+ control structure that has the same behavior as the
  built-in \verb+ateach+, except that the activities are executed in
  sequence instead of being executed in parallel.

\begin{verbatim}
class Sequential {
  public static operator ateach (d: Dist, body:(Point)=>void) {
    for (place in d.places()) {
      at(place) {
        for (p in d|here) { body(p); }
      }
    }
  }
}
\end{verbatim}
\end{example}

\subsection{User-Defined \texttt{while} and \texttt{do}}
% {\scriptsize
% \begin{verbatim}
% userWhileStatement ::=
%     fullyQualifiedName '.' 'while' typeArgumentsopt '(' argumentListopt ')' closureBodyBlock
%   | primary '.' 'while' typeArgumentsopt '(' argumentListopt ')' closureBodyBlock
%   | 'super' '.' 'while' typeArgumentsopt '(' argumentListopt ')' closureBodyBlock
%   | className '.'  'super' '.' 'while' typeArgumentsopt '(' argumentListopt ')' closureBodyBlock
%   ;

% userDoStatement ::=
%     ...
% \end{verbatim}
% }

$$
\begin{array}{rcl}
  \usrWhile{o}{\overline{T}}{\overline{e}}{b}
  & \equiv &
  \libWhile{o}{\overline{T}}{\overline{e}}{b}
  \\

  \usrDo{o}{\overline{T}}{b}{\overline{e}}
  & \equiv &
  \libDo{o}{\overline{T}}{b}{\overline{e}}
\end{array}
$$

The arguments of the user-defined \verb+while+~(resp. \verb+do+) are
evaluated before the call of the \verb+while+~(resp. \verb+do+) method
and the body of the loop is lifted to a closure without argument.
%
Note that compared to usual loop, the condition is evaluated once
before the call of the method that implements the behavior of the
loop.


\begin{example}
  A loop that iterates during at least a given number of milliseconds:
\begin{verbatim}
class Timeout {
  public static operator while(ms: Long, body: ()=>void) {
    val deadline = System.currentTimeMillis() + ms;
    while (System.currentTimeMillis() < deadline) {
      body();
    }
  }
}
\end{verbatim}
Here, we increment a counter during about 10 milliseconds:
\begin{verbatim}
public static def main(Rail[String]) {
  val cpt = new Cell[Long](0);
  Timeout.while(10) {
    atomic { cpt() = cpt() + 1; }
  }
  Console.OUT.println(cpt());
}
\end{verbatim}

\end{example}

\subsection{User-Defined  \texttt{continue}}
% {\scriptsize
% \begin{verbatim}
% userContinueStatement ::=
%     fullyQualifiedName '.' 'continue' typeArgumentsopt expressionopt ';'
%   | primary '.' 'continue' typeArgumentsopt expressionopt ';'
%   | 'super' '.' 'continue' typeArgumentsopt expressionopt ';'
%   | className '.'  'super' '.' 'continue' typeArgumentsopt expressionopt ';'
%   ;
% \end{verbatim}
% }

$$
\begin{array}{rcl}
  \usrContinue{o}{\overline{T}}{e}
  & \equiv &
  \libContinue{o}{\overline{T}}{e}
\end{array}
$$

The argument of a user-defined \verb+continue+ is evaluated before
calling the corresponding method.

\begin{example}
  The following code provides a parallel \verb+for+ loop and a
  \verb+continue+ statement that allows to skip an iteration.
\begin{verbatim}
class Par {
  private static class Continue extends Exception {}

  public static operator continue () {
    throw new Continue();
  }

  public static operator for[T](c: Iterable[T], body:(T)=>void) {
    finish {
      for(x in c) async {
          try {
            body(x);
          } catch (Continue) {}
        }
    }
  }
}
\end{verbatim}
  The following example skip every iteration where the loop index is
  even.
\begin{verbatim}
public static def main(Rail[String]) {
  val cpt = new Cell[Long](0);
  Par.for(i:Long in 1..10) {
    if (i%2 == 0) { Par.continue; }
    atomic { cpt() = cpt() + 1; }
  }
  Console.OUT.println(cpt());
}
\end{verbatim}
\end{example}


\subsection{User-Defined \texttt{break}}
% {\scriptsize
% \begin{verbatim}
% userBreakStatement ::=
%     fullyQualifiedName '.' 'break' typeArgumentsopt expressionopt ';'
%   | primary '.' 'break' typeArgumentsopt expressionopt ';'
%   | 'super' '.' 'break' typeArgumentsopt expressionopt ';'
%   | className '.'  'super' '.' 'break' typeArgumentsopt expressionopt ';'
%   ;
% \end{verbatim}
% }

$$
\begin{array}{rcl}
  \usrBreak{o}{\overline{T}}{e}
  & \equiv &
  \libBreak{o}{\overline{T}}{e}
\end{array}
$$

The argument of a user-defined \verb+break+ is
evaluated before calling the corresponding method.

\begin{example}
  To break out of a user-defined loop, it is necessary to also define
  the \verb+break+ statement:
\begin{verbatim}
class Infinite {
  private static class Break extends Exception {}

  public static operator break () {
    throw new Break();
  }

  public static operator while (body:()=>void) {
    try {
      while(true) {
        body();
      }
    } catch (Break) {}
  }

  public static def main(Rail[String]) {
    Infinite.while() {
      Infinite.break;
    }
    Console.OUT.println("OK");
  }
}
\end{verbatim}
\end{example}

